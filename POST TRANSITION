
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define MAX_STR_LEN 10

typedef struct Package{
  char id[MAX_STR_LEN];
  unsigned weight;
} Package;

typedef struct{
  unsigned min_weight,max_weight,package_count,capacity;
  Package *packages;
} Office;

typedef struct{
  char name[MAX_STR_LEN];
  Office *offices;
  unsigned office_count, package_count;
} Town;

Package read_package()
{
  Package p;
  p.weight=0;
  scanf("%s %u", p.id, &p.weight);
  return p;
}

Office read_office()
{
  Office o;
  scanf("%u %u %u", &o.package_count, &o.min_weight, &o.max_weight);
  o.capacity=o.package_count*2;
  o.packages=malloc(o.capacity*sizeof(Package));
  unsigned n=0;
  while(n<o.package_count)
  {
    o.packages[n]=read_package();
    n++;
  }
  return o;
}

Town read_town()
{
  Town tow;
  scanf("%s %u", tow.name, &tow.office_count);
  tow.offices = malloc(tow.office_count*sizeof(Office));
  unsigned n=0;
  tow.package_count=0;
  while(n<tow.office_count)
  {
    tow.offices[n] = read_office();
    tow.package_count += tow.offices[n].package_count;
    n++;
  }
  return tow;
}


void add_package(Office *o, Package p)
{
  if(o->package_count==o->capacity)
  {
    o->capacity *= 2;
    Package *expanded = malloc(o->capacity*sizeof(Package));
    unsigned n=0;
    while(n<o->package_count)
    {
      expanded[n] = o->packages[n];
      n++;
    }
    free(o->packages);
    o->packages = expanded;
  }
  o->packages[o->package_count++] = p;
}

int is_between(unsigned x, unsigned y, unsigned z){
  return x<=y && y<=z;
}

unsigned send_packages(Office *from, Office *to)
{
  unsigned n,sent_count;
  n=0;
  sent_count=0;
  for(n=0; n<from->package_count; n++)
  {
    if(is_between(to->min_weight, from->packages[n].weight, to->max_weight))
    {
      add_package(to, from->packages[n]);
      ++sent_count;
    }
    else if(sent_count)
    {
      from->packages[n-sent_count] = from->packages[n];
    }
  }
  from->package_count -= sent_count;
  return sent_count;
}

void destroy_office(Office *o)
{
  free(o->packages);
}

void destroy_town(Town *t)
{
  unsigned n=0;
  for(n=0; n<t->office_count; ++n)
  {
    destroy_office(t->offices+n);
  }
  free(t->offices);
}

void print_town(Town *t)
{
  printf("%s:\n", t->name);
  unsigned i,k;
  i=0;
  k=0;
  for(i=0; i<t->office_count; ++i)
    {
    printf("\t%u:\n", i);
    for(k=0; k<t->offices[i].package_count; ++k)
    {
      printf("\t\t%s\n", t->offices[i].packages[k].id);
    }
   }
}

Town *find_town(Town *towns, unsigned count, const char *name)
{
  unsigned n=0;
  for(n=0; n<count; ++n)
  {
    if(strcmp(towns[n].name, name)==0)
    {
      return towns+n;
    }
  }
  return NULL;
}

void execute_read_query(Town *towns, unsigned count)
{
  unsigned qtype,n;
  qtype=0;
  n=0;
  scanf("%u", &qtype);
  char temp_buf[MAX_STR_LEN];
  switch(qtype)
  {
  case 1:
    {
      scanf("%s", temp_buf);
      print_town(find_town(towns, count, temp_buf));
      break;
    }
  case 2:
    {
      scanf("%s", temp_buf);
      Town *source=find_town(towns, count, temp_buf);
      unsigned source_off=0, target_off=0;
      scanf("%u %s %u", &source_off, temp_buf, &target_off);
      Town *target=find_town(towns, count, temp_buf);
      unsigned sent_count = send_packages(source->offices+source_off, target->offices+target_off);
      source->package_count -= sent_count;
      target->package_count += sent_count;
      break;
    }
  case 3:
    {
      unsigned most_packages,ind_most;
        most_packages=0;
        ind_most=0;
      for(n=0; n<count; ++n)
        {
        if(towns[n].package_count > most_packages)
        {
            most_packages = towns[n].package_count;
            ind_most=n;
        }
    }
      printf("Town with the most number of packages is %s\n", towns[ind_most].name);
    }
  }
}

int main()
{
  unsigned towns_count,query_count,n;
  towns_count=0;
   n=0;
  query_count=0;
  towns_count=0;
  scanf("%u", &towns_count);
  Town *towns = malloc(towns_count*sizeof(Town));
  while(n<towns_count)
  {
    towns[n] = read_town();
    n++;
  }
  scanf("%u", &query_count);
  for(n=0; n<query_count; n++)
  {
    execute_read_query(towns, towns_count);
  }
  for(n=0;n<towns_count;n++)
  {
    destroy_town(towns+n);
  }
  free(towns);
}
